---
title: "Analyzing Relational Contracts with R: Part 3"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev="svg", error=TRUE, warning=FALSE, fig.width=5, fig.height=4)
library(dplyr)
library(RelationalContracts)
library(repgame)
```

```{r include=FALSE, eval=FALSE, cache=FALSE}
rmarkdown::render("D:/libraries/RelationalHoldup/RelationalContracts/inst/guide/RelationalContractsBlog2.Rmd")
```

In the third part of the blog series on relational contracting, we study a more complex game, a game of conflict.

Consider two parties that can invest into weapons. The state is described by `x=(x1,x2)` where `x1` and `x2` are integer numbers between `0` and `x.max` that describe the weapon arsenal of each party.

Each period a party can try increase its weapon arsenal by one unit for an investment cost `c.i`. The investment is successful only with an exogenously given success probability. A party can also reduce its arsenal by one unit for free.

Players can decide each period whether or not they want to attack the other player. If player 1 attacks, he inflicts harm of size `x1` on the other player but has attack costs `c.a * x1`. In addition player 1's attack destroys one unit in player 2's weapon arsenal with probability `d_factor*(x1 / x.max)^d_exp`. The parameters `d_factor` and `d_exp` are exogenously given, like all the cost factors. An attack by player 2 has symmetric effects.

Finally each unit in a player's arsenal has an upkeep cost of `c.x` irrespectively of whether it is used for an attack or not.

Note that there are no direct gains from attacking since it involves costs for both sides. Therefore in a Pareto-optimal subgame perfect equilibrium weapons will never be build nor aquired. Yet, the possibility to harm the other player can increase a player's bargaining position. If we assume that relational contracts are newly negotiated over time, i.e. we consider a repeated negotiation equilibrium, players can thus have incentives to aquire weapons.


The following code specifies the game:
```{r}

# Action space for each state
A.fun = function(x1,x2, x.max,...) {
  restore.point("A.fun")
  list(
    A1=list(
      a1=c("wait", if (x1>0) "attack"),
      i1=c(if (x1>0) "d","",if (x1<x.max) "b")
    ),
    A2=list(
      a2=c("wait", if (x2>0) "attack"),
      i2=c(if (x2>0) "d","",if (x2<x.max) "b")
    )
  )
}


# State transition function
trans.fun = function(ax.df,x.max, sp,d.factor=1, d.exp=1,...) {
  restore.point("trans.fun")

  # Compute probability to destroy
  # a weapon unit of other player
  # if one attacks
  ax.df = mutate(ax.df,
    dp1 = d.factor*(x1 / x.max)^d.exp,
    dp2 = d.factor*(x2 / x.max)^d.exp
  )
  

  tr = irv_joint_dist(ax.df,
    irv("b1",default=0,
      irv_val(1, (i1=="b")*sp),
      irv_val(-1, (i1=="d")*1)
    ),
    irv("b2",default=0,
      irv_val(1, (i2=="b")*sp),
      irv_val(-1, (i2=="d")*1)
    ),
    irv("d1",default=0,
      irv_val(1, (h2>0)*dp2)
    ),
    irv("d2",default=0,
      irv_val(1, (h1>0)*dp1)
    )
  )

  tr %>%
    mutate(
      new_x1 = pmax(x1+b1-d1,0),
      new_x2 = pmax(x2+b2-d2,0),
      xd = paste0(new_x1,"_",new_x2),
      xs=x
    ) %>%
    group_by(xs,xd,i1,i2,h1,h2) %>%
    summarize(prob = sum(prob))
}

# Maximum size of weapons arsenal
x.max = 3
x.df = tidyr::expand_grid(x1=0:x.max,x2=0:x.max) %>%
  mutate(x = paste0(x1,"_", x2))


g = rel_game("Arms Race") %>%
  rel_param(delta=0.9, rho=0.4, c.a=0.1,c.i=0.1, c.x=0.01,x.max=x.max, sp=0.5, d.factor=0.8, d.exp=1) %>%
  rel_states(x.df,A.fun=A.fun, trans.fun=trans.fun,
    pi1 = -c.a*(a1=="attack")*x1 - (a2=="attack")*x2 - c.i*(i1=="b")-c.x*x1,
    pi2 = -c.a*(a2=="attack")*x2 - (a1=="attack")*x1 - c.i*(i2=="b")-c.x*x2
  ) %>%
  rel_compile() %>%
  rel_capped_rne(T=1000)

rne = get_eq(g)

df.li = eq_diagram(g, show.own.loop = !TRUE, just.eq.chain = !TRUE, return.dfs = TRUE, passive.edge.width = 0)
edf = df.li$edf
ndf = left_join(df.li$ndf, rne, by="x")
ndf = ndf %>% mutate(
  conflict = ae.h1 != 0 | ae.h2 != 0,
  shape = ifelse(conflict, "box","circle"),
  type = ifelse(conflict, "conflict_node", "peace_node")
)
graph = create_graph(ndf, edf)
render_graph(graph, output="visNetwork")



eq_diagram(g, show.own.loop = !TRUE, just.eq.chain = TRUE)

```
