---
title: "Analyzing Relational Contracts with R: Part 3"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev="svg", error=TRUE, warning=FALSE, fig.width=5, fig.height=4)
library(dplyr)
library(RelationalContracts)
library(repgame)
```

```{r include=FALSE, eval=FALSE, cache=FALSE}
rmarkdown::render("D:/libraries/RelationalHoldup/RelationalContracts/inst/guide/RelationalContractsBlog2.Rmd")
```

In the third part of the blog series on relational contracting, we study more complex arms race games.

Consider two parties that can invest into weapons. The state is described by `x=(x1,x2)` where `x1` and `x2` are integer numbers between `0` and `x.max=3` that describe the weapon arsenal of each party.

Each period each party can try increase its weapon arsenal by one unit for an investment cost `c.I`. The investment is successful only with an exogenously given success probability `pi.I=0.08`. A party can also reduce its arsenal by one unit for free. 

Players can decide each period whether or not they want to attack the other player. If player 1 attacks, he inflicts harm of size `x1` on the other player but has attack costs `c.a * x1`.

Each unit in a player's arsenal has maintance cost of `c.m` irrespectively of whether it is used for an attack or not. All cost parameters `c.m`, `c.a`, `c.i` shall be strictly positive.

The following code specifies the game:
```{r}
libarary(RelationalContracts)
# Action space for each state
# a1, a2: (w)ait or (a)ttack
# i1, i2: (b)uild new weapons, (d)estroy own weapons
A.fun = function(x1,x2, x.max,...) {
  restore.point("A.fun")
  list(
    A1=list(
      a1=c("w", if (x1>0) "a"),
      i1=c(if (x1>0) "d","",if (x1<x.max) "b")
    ),
    A2=list(
      a2=c("w", if (x2>0) "a"),
      i2=c(if (x2>0) "d","",if (x2<x.max) "b")
    )
  )
}

# State transition function
trans.fun = function(ax.df,x.max, sp,...) {
  restore.point("trans.fun")

  # The changes in x1 and x2 are
  # independent random variables.
  tr = ax.df %>% 
    select(x,x1,x2,i1,i2) %>%
    distinct() %>%
    irv_joint_dist(
    irv("change_1",default=0,
      irv_val(1, (i1=="b")*sp),
      irv_val(-1, (i1=="d")*1)
    ),
    irv("change_2",default=0,
      irv_val(1, (i2=="b")*sp),
      irv_val(-1, (i2=="d")*1)
    )
  )

  tr %>%
    mutate(
      new_x1 = x1+change_1,
      new_x2 = x2+change_2,
      xd = paste0(new_x1,"_",new_x2),
      xs=x
    ) %>%
    group_by(xs,xd,i1,i2) %>%
    summarize(prob = sum(prob))
}

# Maximum size of weapons arsenal
x.max = 3
x.df = tidyr::expand_grid(x1=0:x.max,x2=0:x.max) %>%
  mutate(x = paste0(x1,"_", x2))


# Specify game
g = rel_game("Arms Race") %>%
  rel_param(delta=0.99, rho=0.65, c.a=0.05,c.i=0.01, c.x=0.2,x.max=x.max, sp=0.08) %>%
  rel_states(x.df,A.fun=A.fun, trans.fun=trans.fun,
    pi1 = -c.a*(a1=="a")*x1 - (a2=="a")*x2 - c.i*(i1=="b")-c.x*x1,
    pi2 = -c.a*(a2=="a")*x2 - (a1=="a")*x1 - c.i*(i2=="b")-c.x*x2
  )
```

Note that we specify the action sets such that player 1 (and equivalently player 2) can only build new weapons (`i1="b"`) if `x1 < x.max`. Similarly, she can only destroy weapons (`i1="d"`) and attack (`a1="a"`) if `x1 > 0`. The most difficult part in a game specification is  the transition function `trans.fun`. Take a look at the vignette on [Specifying Games](Link Here) for an introduction how to facilitate this definition with  the function `irv_joint_dist`.

The following code solves for a Pareto-optimal SPE of this arms race game.
```{r}
g.spe = g %>% rel_spe(delta=0.99)
get_eq(g.spe) %>%
  select(x, ae.lab)
```
We see that on the equilibrium path weapons will never be build and there are no attacks. Moreover, existing weapons will always be destroyed.

This is the case in every Pareto-optimal SPE. There is simply no direct benefit from aquiring, maintaining and using weapons: it only involves costs. The only reason to aquire weapons would be that the threat of using them increases a player's bargaining position and allows him to extort payments from the other player. However, in a Pareto-optimal SPE, players can perfectly coordinate to ignore such threats.

We now solve a repeated negotiation equilibrium (RNE) in which we assume that with probability `rho=0.65` players newly negotiate their relational contract at the beginning of a period. For numerical tractability we also assume that only in the first `T=1000` periods new negotiations can take place, i.e. we compute a so called T-RNE (see the previous blog post for background.)


```{r}
g.rne = g %>% rel_compile() %>% rel_T_rne(g, T=1000, delta=0.99, rho=0.65,use.cpp = FALSE)

eq_diagram(g.rne)


df.li = eq_diagram(g, show.own.loop = !TRUE, just.eq.chain = !TRUE, return.dfs = TRUE, passive.edge.width = 0)


edf = df.li$edf
ndf = left_join(df.li$ndf, rne, by="x")
ndf = ndf %>% mutate(
  conflict = ae.a1 == "attack" | ae.a2 == "attack",
  shape = ifelse(conflict, "box","circle"),
  type = ifelse(conflict, "conflict_node", "peace_node"),
  label = paste0(x1, " ",x2), 
  font = "28px Arial black"
)
graph = create_graph(ndf, edf)
render_graph(graph, output="visNetwork")

```


Note that there are no direct gains from attacking since it involves costs for both sides. Therefore in a Pareto-optimal subgame perfect equilibrium weapons will never be build nor aquired. Yet, the possibility to harm the other player can increase a player's bargaining position. If we assume that relational contracts are newly negotiated over time, i.e. we consider a repeated negotiation equilibrium, players can thus have incentives to aquire weapons.


````{r }


```

##

In addition player 1's attack destroys one unit in player 2's weapon arsenal with probability `d_factor*(x1 / x.max)^d_exp`. The parameters `d_factor` and `d_exp` are exogenously given, like all the cost factors. An attack by player 2 has symmetric effects.



## Consider only one active player

```{r}
# Action space for each state
A.fun = function(x1,x2,ap, x.max,...) {
  restore.point("A.fun")
  list(
    A1=if (ap==1) list(
      a1=c("wait", if (x1>0) "attack"),
      i1=c(if (x1>0) "d","",if (x1<x.max) "b")
    ),
    A2= if (ap==2) list(
      a2=c("wait", if (x2>0) "attack"),
      i2=c(if (x2>0) "d","",if (x2<x.max) "b")
    )
  )
}

pi.fun = function(ax.df,c.a,c.x,c.i, ...) {
  restore.point("pi.fun")
  ax1 = filter(ax.df, ap==1) %>%
    mutate(
      pi1 = -c.a*(a1=="attack")*x1  - c.i*(i1=="b")-c.x*x1,
      pi2 = - (a1=="attack")*x1 -c.x*x2
    )
  ax2 = filter(ax.df, ap==2) %>%
    mutate(
      pi1 = - (a2=="attack")*x2 -c.x*x1,
      pi2 = -c.a*(a2=="attack")*x2 - c.i*(i2=="b")-c.x*x2
    )
  bind_rows(ax1,ax2)
}

# State transition function
trans.fun = function(ax.df,x.max, sp,d.factor=1, d.exp=1,...) {
  restore.point("trans.fun")

  # Compute probability to destroy
  # a weapon unit of other player
  # if one attacks
  ax.df = mutate(ax.df,
    i = ifelse(ap==1,i1,i2),
    a = ifelse(ap==1,a1,a2),
    xi = ifelse(ap==1,x1,x2),
    xj = ifelse(ap==1,x2,x1),
    dp = d.factor*(xi / x.max)^d.exp
  )
  
  tr = ax.df %>% 
    distinct(ap,xi,xj,i,a) %>%
    left_join(ax.df, by = c("ap", "xi", "xj", "i", "a"))
  

  tr = irv_joint_dist(tr,
    irv("bi",default=0,
      irv_val(1, (i=="b")*sp),
      irv_val(-1, (i=="d")*1)
    ),
    irv("dj",default=0,
      irv_val(1, (a=="attack")*dp)
    ),
    irv("new_ap",irv_val(1, 0.5), irv_val(2, 0.5))
  )

  tr = tr %>%
    mutate(
      new_xi = pmax(xi+bi,0),
      new_xj = pmax(xj-dj,0),
      new_x1 = ifelse(ap==1, new_xi,new_xj),
      new_x2 = ifelse(ap==1, new_xj,new_xi),
      xd = paste0("p",new_ap,"_",new_x1,"_",new_x2),
      xs=x
    )
  tr
  
  test = tr %>%
    select(xs,xd,ap,i1,i2,a1,a2, prob)
}

# Maximum size of weapons arsenal
x.max = 3
x.df1 = tidyr::expand_grid(ap=1,x1=0:x.max,x2=0:x.max)  
x.df2 = x.df1 %>% mutate(ap=2)
x.df = bind_rows(x.df1, x.df2) %>%
  mutate(
    x = paste0("p",ap,"_" ,x1,"_", x2),
    xgroup = paste0(x1,"_",x2)
  )

g = rel_game("Arms Race Turns") %>%
  rel_param(delta=0.9, rho=0.6, c.a=0.012,c.i=0.01, c.x=0.01,x.max=x.max, sp=0.2, d.factor=0.8, d.exp=2) %>%
  rel_states(x.df,A.fun=A.fun, trans.fun=trans.fun,pi.fun=pi.fun) %>%
  rel_compile()

g = g %>% rel_capped_rne(T=1001)

rne = get_eq(g)
plot.turns.arms.race(g)

plot.turns.arms.race = function(g, eq=get_eq(g), simple.label=TRUE) {

  eq_group = eq %>%
    group_by(x1,x2, xgroup) %>%
    summarize(
      attack1 = any(ae.a1=="attack", na.rm=TRUE),
      attack2 = any(ae.a2=="attack", na.rm=TRUE),
      b1 = any(ae.i1=="b", na.rm=TRUE),
      b2 = any(ae.i2=="b", na.rm=TRUE),
      d1 = any(ae.i1=="d", na.rm=TRUE),
      d2 = any(ae.i2=="d", na.rm=TRUE),
      r1 = round(mean(r1),1),
      r2 = round(mean(r2),1)
    )

  res = eq_diagram_xgroup(g,return.dfs = TRUE, passive.edge.width = 0)
  edf = res$edf
    
  ndf = left_join(res$ndf, eq_group, by="xgroup")
  ndf = ndf %>% mutate(
    conflict = attack1 | attack2,
    shape = ifelse(conflict, "box","circle"),
    type = ifelse(conflict, "conflict_node", "peace_node"),
    title = paste0(xgroup,"<br>", 
      ifelse(attack1,"a","w"), ifelse(b1,"b","") , ifelse(d1,"d",""),
      "_",
      ifelse(attack2,"a","w"),ifelse(b2,"b","") , ifelse(d2,"d",""),
      "<br>",
      r1, "_",r2
    )

  )
  if (!simple.label) {
    ndf = ndf%>% mutate(
      label = paste0(xgroup,"\n", 
        ifelse(attack1,"a",""), ifelse(b1,"b","") , ifelse(d1,"d",""),
        " ",
        ifelse(attack2,"a",""),ifelse(b2,"b","") , ifelse(d2,"d",""),
        "\n",
        r1, " ",r2
      )
    )
  } else {
    ndf = ndf%>% mutate(
      label = paste0(x1," ",x2),
      font = "30px Arial black"
    )
  }
  
  graph = create_graph(ndf, edf)
  render_graph(graph, output="visNetwork")
}

```

Try to understand why with low attack cost in state "3_1" player 2 does not attack, while he does attack with high attack costs. 
```{r}

gL = rel_game("Arms Race Turns") %>%
  rel_param(delta=0.9, rho=0.6, c.a=0.01,c.i=0.01, c.x=0.01,x.max=x.max, sp=0.2, d.factor=0.8, d.exp=2) %>%
  rel_states(x.df,A.fun=A.fun, trans.fun=trans.fun,pi.fun=pi.fun) %>%
  rel_capped_rne(T=1000,save.details = TRUE)


gH = rel_game("Arms Race Turns") %>%
  rel_param(delta=0.9, rho=0.6, c.a=0.1,c.i=0.01, c.x=0.01,x.max=x.max, sp=0.2, d.factor=0.8, d.exp=2) %>%
  rel_states(x.df,A.fun=A.fun, trans.fun=trans.fun,pi.fun=pi.fun) %>%
  rel_capped_rne(T=1000,save.details = TRUE)

plot.turns.arms.race(gL)
plot.turns.arms.race(gH)


detL = get_rne_details(gL)
detH = get_rne_details(gH)


detL$scen = "L"
detH$scen = "H"

det = bind_rows(detL, detH) %>%
  select(scen,x1,x2,a2,i2, IC.holds,can.ae,can.a2,can.a1,U.hat,Er1,Er2,pi1,pi2, everything())

d = det %>%
  filter(x1==3, x2==1, ap==2)# %>%
  #arrange(a2,i2,scen)


d = det %>%
  filter(x1==0, x2==2, ap==2) %>%
  arrange(a2,i2,scen)


rne = get_eq(g)
plot.turns.arms.race(g)

```

